# [프로그래머스(단속카메라)](https://programmers.co.kr/learn/courses/30/lessons/42884#)

---

```javascript
//정답코드 (https://kyun2da.github.io/2020/07/20/checkCamera/) 이곳의 코드를 보았다.
function solution(routes) {
    //오른쪽 축을 기준으로 오름차순 정렬한다
    routes.sort((a, b)=>{
        return a[1] - b[1]
    })
    //단속카메라 한 개를 설치하고 시작
    let chkNum = routes[0][1]
    let ans = 1
    //routes 원소의 좌측 시작이 기존에 설정해놓은 chkNum(우측 원소를 기준으로 설정해둠) 보다 크다면 새로운 단
    //속카메라가 필요
    for(let i=1;i<routes.length;i++){
        if(routes[i][0] > chkNum){            
            chkNum = routes[i][1]
            ans++         
        }       
    }
    return ans;
}
```



```javascript
//기존의 내 코드
function solution(routes) {
	routes.sort((a, b)=>{
    	return a[0] - b[0]
	})

	let chkNum = routes[0][1]
	let ans = 1
	for(let i=1;i<routes.length;i++){
    	if(routes[i][0] <= chkNum){
       	 if(routes[i-1][1] > routes[i][1])
       	 	chkNum = routes[i][1]      	
        	continue
    	 }
   		 ans++
     	 chkNum = routes[i][1]
	}
	return ans;
}
```

---

가장 먼저 이 문제를 보았을 때, 60000 크기의 배열을 만들어 그곳에 push하는 식으로 만들어봐야겠다 생각이 들었다. 

즉, `[[-20,15], [-14,-5], [-18,-13], [-5,-3]]` 이 테스트 케이스의 경우 visited 배열의 -20~15에 0을 push, -14~-5에 1을 push -18~-13에 2를 push, -5~-3에 3을 push하는 식으로 구상하였다.

미친듯이 비효율적인 구상이다. 하지만, 한 번 끝까지 이런 식으로 구해봐야겠다라는 고집(?)이 생겨 시도해보다가 포기했다.

그 과정에서 c++의 vector처럼 자바스크립트의 배열을 활용하는 방법을 찾았다. 

`let visited = new Array(60000).fill([])`

혹시하는 생각에 fill 속에 빈배열을 넣어봤더니 잘 동작한다. 이렇게 빈배열을 넣어두고 push를 사용해서 해당 배열을 채워나가게 되면 2차원 vector의 모양과 똑같아진다. 앞으로 많이 써먹을 수 있는 선언부인 것 같다.

---

하지만, 위와 같은 방법은 극한의 비효율(60000크기의 배열을 몇번이나 순회해야 한다.)이기 때문에 다른 방법을 생각했다. 바로 routes 요소들의 첫번째 원소를 기준으로 정렬한 다음 routes 요소들의 두번째 원소들을 활용하여 폭을 줄여나가는 방식이다. 줄여나가는 과정에서도 `routes[i][1]`의 값이 `routes[i-1][1]`의 값보다 작을 때만 그 폭을 줄일 수 있도록 구성하였다.

만약 폭의 가장 오른쪽보다 새로 들어오는 요소의 가장 왼쪽이 더 크다면 단속카메라의 개수를 하나 증가시키는 방식이다.

이렇게 해서 테스트케이스를 통과했고 질문하기에 있는 다른 테스트케이스들도 통과했다. 그런데 막상 제출을 하게 되면 전부 틀렸다는 결과가 나왔다. 

이해가 잘 되지 않아 다른 사람들의 코드를 보다가 맨 위의 코드와 비슷한 코드를 보았다. 그곳에서는 왼쪽을 기준으로 정렬하는 것이 아니라 오른쪽을 기준으로 정렬하고 사용하고 있었다. 내 코드에서 기준점을 오른쪽으로 바꿔보니까 내 코드도 정답 처리가 되었다. 근데 아직까지도 왜 왼쪽 정렬을 하면 틀리게 나오는지 이해가 가지 않는다.... 다른 테스트케이스들을 뒤져서 어느 부분이 잘못되었는지 찾아봐야겠다.

---

## 💤느낀점

뭔가... 그리디한 문제들은 풀어본 경험이 거의 전무해서 처음에 어떻게 접근해야할 지 감이 잡히지 않는 경우가 많은 것 같다. 많은 연습이 필요하겠다...